---
title: "BOJ 23827 수열 (Easy)"
category: "알고리즘"
author: kuper0201
tags: ['#algorithm']
date: 2023-05-25
slug: boj23827
thumbnail: cover.jpg
---

import "katex/dist/katex.min.css";

## 문제

### <a href="https://boj.kr/23827" target="_blank">BOJ 23827 수열 (Easy)</a>

모든 원소가 양의 정수이고, 길이가 
$N$인 수열 
$A_1, A_2, ..., A_N$이 주어진다. 
$1 \le i < j \le N$을 만족하는 모든 정수쌍 
$(i, j)$에 대해 
$A_i \times A_j$의 합을 
$1\, 000 \, 000 \, 007$로 나눈 나머지를 구하시오.

---

## 입력

첫째 줄에 수열 
$A$의 길이 
$N$이 주어진다.

둘째 줄에 수열 
$A_1, A_2, \cdots, A_N$이 공백으로 구분되어 주어진다.

---

## 풀이



<details markdown="1">
<summary>코드 보기(Java)</summary>

```javascript
import java.io.*;

public class Main {
    static int[] score, memo;

    public static void main(String[] args) throws Exception {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

        // 계단의 개수 입력
        int N = Integer.parseInt(br.readLine());
        score = new int[N];
        memo = new int[N];

        // 계단별 점수 입력
        for(int i = 0; i < N; i++) {
            score[i] = Integer.parseInt(br.readLine());
        }

        memo[0] = score[0]; // 첫 항 설정
        System.out.println(recursive(N - 1)); // 재귀함수 호출
    }

    // DP 수행하는 재귀 함수
    public static int recursive(int n) {
        if(n < 0) return 0; // 음수번째 계단은 없으므로 0 반환
        if(memo[n] != 0) return memo[n]; // 이전에 계산한 값 존재하면 계산 불필요

        int tmp1 = recursive(n - 3) + score[n - 1]; // 3층 이전의 값 + 1층 이전의 값
        int tmp2 = recursive(n - 2); // 2층 이전의 값

        // N번째 계단까지 점수의 최대는 (N - 1)최대 + N번째 계단 점수
        memo[n] = Math.max(tmp1, tmp2) + score[n];

        return memo[n];
    }
}
```
</details>

<details markdown="1">
<summary>코드 보기(C++)</summary>

```cpp
#include <iostream>
#include <algorithm>
#include <vector>
#include <set>

#define fastio ios_base::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr)
#define endl '\n'

using namespace std;

int *score, *memo;

// DP 수행하는 재귀 함수
int recursive(int n) {
    if(n < 0) return 0; // 음수번째 계단은 없으므로 0 반환
    if(memo[n] != 0) return memo[n]; // 이전에 계산한 값 존재하면 계산 불필요

    int tmp1 = recursive(n - 3) + score[n - 1]; // 3층 이전의 값 + 1층 이전의 값
    int tmp2 = recursive(n - 2); // 2층 이전의 값

    // N번째 계단까지 점수의 최대는 (N - 1)최대 + N번째 계단 점수
    memo[n] = max(tmp1, tmp2) + score[n];

    return memo[n];
}

int main() {
    fastio;
    
    // 계단의 개수 입력
    int N;
    cin >> N;
    
    score = new int[N]{0, };
    memo = new int[N]{0, };
    
    // 계단별 점수 입력
    for(int i = 0; i < N; i++) {
        cin >> score[i];
    }

    memo[0] = score[0]; // 첫 항 설정
    cout << recursive(N - 1) << endl; // 재귀함수 호출
    
    return 0;
}
```
</details>

<details markdown="1">
<summary>코드 보기(Kotlin)</summary>

```javascript
lateinit var score: Array<Int>
lateinit var memo: Array<Int>

// DP 수행하는 재귀 함수
fun recursive(n: Int): Int {
    if(n < 0) return 0 // 음수번째 계단은 없으므로 0 반환
    if(memo[n] != 0) return memo[n] // 이전에 계산한 값 존재하면 계산 불필요

    var tmp1 = recursive(n - 3) + score[n - 1] // 3층 이전의 값 + 1층 이전의 값
    var tmp2 = recursive(n - 2) // 2층 이전의 값

    // N번째 계단까지 점수의 최대는 (N - 1)최대 + N번째 계단 점수
    memo[n] = Math.max(tmp1, tmp2) + score[n]

    return memo[n]
}

fun main(args: Array<String>) = with(System.`in`.bufferedReader()) {
    // 계단의 개수 입력
    var N = readLine().toInt()
    
    score = Array<Int>(N, {0})
    memo = Array<Int>(N, {0})
    
    // 계단별 점수 입력
    for(i in 0 until N) {
        score[i] = readLine().toInt()
    }

    memo[0] = score[0] // 첫 항 설정
    println(recursive(N - 1)) // 재귀함수 호출
}
```
</details>

<details markdown="1">
<summary>코드 보기(Python)</summary>

```python
from sys import stdin

score = None
memo = None

# DP 수행하는 재귀 함수
def recursive(n):
    global score, memo

    if n < 0:
        return 0 # 음수번째 계단은 없으므로 0 반환
    if memo[n] != 0:
        return memo[n] # 이전에 계산한 값 존재하면 계산 불필요

    tmp1 = recursive(n - 3) + score[n - 1] # 3층 이전의 값 + 1층 이전의 값
    tmp2 = recursive(n - 2) # 2층 이전의 값

    # N번째 계단까지 점수의 최대는 (N - 1)최대 + N번째 계단 점수
    memo[n] = max(tmp1, tmp2) + score[n]

    return memo[n]

def main():
    # 계단의 개수 입력
    N = int(stdin.readline())

    global score, memo
    score = [0] * N
    memo = [0] * N

    # 계단별 점수 입력
    for i in range(N):
        score[i] = int(stdin.readline())

    memo[0] = score[0]  # 첫 항 설정
    print(recursive(N - 1))  # 재귀함수 호출

if __name__ == "__main__":
    main()
```
</details>

<details markdown="1">
<summary>코드 보기(Swift)</summary>

```cpp
import Foundation

var score: Array<Int>!
var memo: Array<Int>!

// DP 수행하는 재귀 함수
func recursive(n: Int)-> Int {
    if(n < 0) {
        // 음수번째 계단은 없으므로 0 반환
        return 0
    }
    
    if(memo[n] != 0) {
        // 이전에 계산한 값 존재하면 계산 불필요
        return memo[n]
    }

    var tmp1 = recursive(n: n - 3) + score[n - 1] // 3층 이전의 값 + 1층 이전의 값
    var tmp2 = recursive(n: n - 2) // 2층 이전의 값

    // N번째 계단까지 점수의 최대는 (N - 1)최대 + N번째 계단 점수
    memo[n] = max(tmp1, tmp2) + score[n]

    return memo[n]
}

func main() {
    // 계단의 개수 입력
    var N = Int(readLine()!)!
    
    score = Array<Int>(repeating: 0, count: N)
    memo = Array<Int>(repeating: 0, count: N)
    
    // 계단별 점수 입력
    for i in 0..<N {
        score[i] = Int(readLine()!)!
    }

    memo[0] = score[0] // 첫 항 설정
    print(recursive(n: N - 1)) // 재귀함수 호출
}

main()
```
</details>